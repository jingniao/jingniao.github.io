<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惊鸟的技术小站</title>
  
  <subtitle>坚持记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingniao.github.io/"/>
  <updated>2019-08-06T01:12:29.485Z</updated>
  <id>https://jingniao.github.io/</id>
  
  <author>
    <name>惊鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端知识零碎</title>
    <link href="https://jingniao.github.io/2018/10/18/js-dialog/"/>
    <id>https://jingniao.github.io/2018/10/18/js-dialog/</id>
    <published>2018-10-18T22:00:16.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="弹框效果遮罩"><a href="#弹框效果遮罩" class="headerlink" title="弹框效果遮罩"></a>弹框效果遮罩</h1><h2 id="代码-amp-效果"><a href="#代码-amp-效果" class="headerlink" title="代码&amp;效果"></a>代码&amp;效果</h2><p><a href="https://github.com/jingniao/blogdemo/blob/master/dialog.html" target="_blank" rel="noopener">代码</a><br><a href="https://letus.club/blogdemo/dialog.html" target="_blank" rel="noopener">效果</a></p><h2 id="CSS属性"><a href="#CSS属性" class="headerlink" title="CSS属性"></a>CSS属性</h2><p><code>position:fixed</code> 元素定位相当于当前屏幕视窗（viewport）指定位置<br><code>z-index:9999</code> 元素的堆叠层数，弹框处于最上层，遮罩处于弹框下层<br><code>opacity: 0.4;</code> 透明度 w3c 推荐  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;弹框效果遮罩&quot;&gt;&lt;a href=&quot;#弹框效果遮罩&quot; class=&quot;headerlink&quot; title=&quot;弹框效果遮罩&quot;&gt;&lt;/a&gt;弹框效果遮罩&lt;/h1&gt;&lt;h2 id=&quot;代码-amp-效果&quot;&gt;&lt;a href=&quot;#代码-amp-效果&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="html" scheme="https://jingniao.github.io/tags/html/"/>
    
      <category term="css" scheme="https://jingniao.github.io/tags/css/"/>
    
      <category term="jquery" scheme="https://jingniao.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Python的pickle以及其他的序列化</title>
    <link href="https://jingniao.github.io/2018/09/28/python-pickle-and-other/"/>
    <id>https://jingniao.github.io/2018/09/28/python-pickle-and-other/</id>
    <published>2018-09-28T22:24:10.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<p>之前在论坛上看到说<code>Python</code>内存占用的问题，有个回复说<code>不少人还认为pickle是直接将内存中的数据到处到文件里了</code>，很羞愧，看到这句话之前，我也是这么认为的……<br>这篇文章就是对这些进行简单的摸底，做到心中有数，从这么看来说，之前写的部分代码坑不小……<br><a id="more"></a><br>一、python的字典内存占用以及pickle输出大小<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">result = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    result[str(i).encode(<span class="string">'utf-8'</span>)] = str(i).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">print(sys.getsizeof(result))</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.pk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(result, f)</span><br></pre></td></tr></table></figure></p><p>在我本机 <code>windows10 python 3.7</code>，内存中：41943144，导出后的pickle文件大小为25778963<br>内存多了62%<br>这是<code>str:str</code><br><code>int:int</code>  41943144: 9739352，大概膨胀了4倍多<br>key范围扩大到 40000000后，内存占用为2525MB</p><h1 id="二、golang内存占用"><a href="#二、golang内存占用" class="headerlink" title="二、golang内存占用"></a>二、golang内存占用</h1><p>1-n的key范围     内存<br>1000000         81MB<br>2000000         162MB<br>3000000         168MB<br>4000000         320MB<br>5000000         330MB<br>10000000        650MB<br>20000000        1281MB<br>40000000        2540MB<br>在<code>map</code>中，平均每增加一个<code>int:int</code> key，内存增加66<code>byte</code><br>将<code>int</code>更换为<code>int32 int32</code>再尝试<br>40000000        1417MB 降低还是很明显<br>代码如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">int2int</span><span class="params">()</span> <span class="title">map</span>[<span class="title">int32</span>]<span class="title">int32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>)</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">40000000</span>; i++ &#123;</span><br><span class="line">res[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i2i := int2int()</span><br><span class="line"><span class="keyword">var</span> aa <span class="keyword">int32</span></span><br><span class="line">fmt.Println(unsafe.Sizeof(aa))</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(i2i))</span><br><span class="line">fmt.Scanln()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这只是简单的对比，没有说哪个优秀之类的，并且这个对比如果硬要对比的话肯定有不少地方不公平，但是单单对<code>map int:int</code> 这种类型来说，<code>python</code>跟<code>golang</code>的内存占用差距比我想象中的要小</p><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><p><code>go</code>中类似<code>python</code>的<code>pickle</code>的是<code>encoding/gob</code>？有空补上对比</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在论坛上看到说&lt;code&gt;Python&lt;/code&gt;内存占用的问题，有个回复说&lt;code&gt;不少人还认为pickle是直接将内存中的数据到处到文件里了&lt;/code&gt;，很羞愧，看到这句话之前，我也是这么认为的……&lt;br&gt;这篇文章就是对这些进行简单的摸底，做到心中有数，从这么看来说，之前写的部分代码坑不小……&lt;br&gt;
    
    </summary>
    
    
      <category term="python,go,pickle" scheme="https://jingniao.github.io/tags/python-go-pickle/"/>
    
  </entry>
  
  <entry>
    <title>django升级-从1.6到1.11</title>
    <link href="https://jingniao.github.io/2018/09/14/django-upgrade/"/>
    <id>https://jingniao.github.io/2018/09/14/django-upgrade/</id>
    <published>2018-09-14T21:46:10.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="升级套路"><a href="#升级套路" class="headerlink" title="升级套路"></a>升级套路</h1><p>基本上是将Django大版本升级，这三条命令循环逐步升级到<code>&lt;2</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install -U "Django&lt;1.8"</span><br><span class="line">python manage.py runserver</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="中间更改项"><a href="#中间更改项" class="headerlink" title="中间更改项"></a>中间更改项</h1><h2 id="urls-py更改"><a href="#urls-py更改" class="headerlink" title="urls.py更改"></a>urls.py更改</h2><p><code>from django.conf.urls import patterns</code><br>patterns  弃用<br>urlpatterns从 patterns的实例变为一个普通的数组或者元组<br><code>url(r&#39;^test$&#39;, &#39;test.views.snips&#39;, name=&#39;snip&#39;)</code>方式不不再可用，将url的第二个参数替换为views函数或者其他可直接引用的函数</p><h2 id="配置的修改"><a href="#配置的修改" class="headerlink" title="配置的修改"></a>配置的修改</h2><p>settings.py中<br>zh-cn到zh-hans<br>TEMPLATES添加（还没有研究这个设置详情）<br>TEMPLATE_* （应该是被TEMPLATES替代了）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这还是一个不那么老的项目，而且代码量很少，剩下的就难看了，也没有动力去整</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;升级套路&quot;&gt;&lt;a href=&quot;#升级套路&quot; class=&quot;headerlink&quot; title=&quot;升级套路&quot;&gt;&lt;/a&gt;升级套路&lt;/h1&gt;&lt;p&gt;基本上是将Django大版本升级，这三条命令循环逐步升级到&lt;code&gt;&amp;lt;2&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install -U &quot;Django&amp;lt;1.8&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;python manage.py runserver&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;python manage.py migrate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>云服务笔记（持续更新，更新随缘）</title>
    <link href="https://jingniao.github.io/2018/07/14/kvm-install-iso/"/>
    <id>https://jingniao.github.io/2018/07/14/kvm-install-iso/</id>
    <published>2018-07-14T16:31:24.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在云服务上安装自定义ISO"><a href="#在云服务上安装自定义ISO" class="headerlink" title="在云服务上安装自定义ISO"></a>在云服务上安装自定义ISO</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>国内阿里云在都不支持iso直接安装系统（vultr支持，很方便）。相信前几个月在xx云组团买小鸡的人不少。官方的镜像没那个精力去排查是否装了什么奇奇怪怪的东西，自己从ISO安装，不管是否真的更加安全，这是一种选择。在只有ECS服务没有其他增值服务（挂载第二块磁盘）的时候，会比较不方便</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>修改系统grub2的配置，增大超时时间，以便重启系统是可以进入grub2手动输入命令进行引导ISO镜像<a id="more"></a></li><li>下载gparted ISO（有官方版）到虚拟机上，放到容易找到的地方（建议根目录）</li><li>重启进入grub2，键盘c键，进入grub2的命令行模式，引导gparted ISO <a href="https://gparted.org/livehd.php" target="_blank" rel="noopener">gparted官方硬盘live引导文档</a>启动</li><li>gparted引导后，会出现一个gparted ISO自己的grub2的引导界面，选择更多，里面有个载入内存的选项（提示可以随后拔掉光驱之类的），从这里进入</li><li>进入gparted live系统后，使用gparted对系统进行分区，建议分出2个区，第一个用于稍后安装系统，第二个用于存放需要安装的系统盘ISO，第二个分区大小看你准备了什么盘，例如 centos 7 DVD你就最好留出5GB的大小</li><li>挂载第二个分区，下载（gparted live可以联网）将要安装的系统ISO到第二个分区内</li><li>安装grub2到硬盘中（grub2安装需要指定配置文件路径才能安装，可以指定第二个盘的挂载点，会生成boot目录以及grub目录）</li><li>重启后会进入上一步从gparted安装的grub2，然后使用grub2 命令引导ISO安装，接下来就是正常的系统安装过程了 推荐这里<a href="http://giveme5.cc/2017/06/27/linux/linuxUsbGrub/" target="_blank" rel="noopener">grub2引导各系统</a></li></ol><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>Q：为什么要额外分区，直接使用原有系统的grub2引导想要安装的系统ISO不行么？<br>    A：安装程序从硬盘ISO引导时，会将ISO文件挂载到live的系统中，这样占用唯一的一个分区（ISO在这个分区），这样安装程序不能正常的进行分区，或者分区后无法正常刷新分区表，最后造成安装失败</p><h2 id="失败重来"><a href="#失败重来" class="headerlink" title="失败重来"></a>失败重来</h2><p>强制关闭主机，将磁盘重新初始化</p><h2 id="以上操作在阿里云实验成功，腾讯云应该也类似"><a href="#以上操作在阿里云实验成功，腾讯云应该也类似" class="headerlink" title="以上操作在阿里云实验成功，腾讯云应该也类似"></a>以上操作在阿里云实验成功，腾讯云应该也类似</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在云服务上安装自定义ISO&quot;&gt;&lt;a href=&quot;#在云服务上安装自定义ISO&quot; class=&quot;headerlink&quot; title=&quot;在云服务上安装自定义ISO&quot;&gt;&lt;/a&gt;在云服务上安装自定义ISO&lt;/h1&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;国内阿里云在都不支持iso直接安装系统（vultr支持，很方便）。相信前几个月在xx云组团买小鸡的人不少。官方的镜像没那个精力去排查是否装了什么奇奇怪怪的东西，自己从ISO安装，不管是否真的更加安全，这是一种选择。在只有ECS服务没有其他增值服务（挂载第二块磁盘）的时候，会比较不方便&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;修改系统grub2的配置，增大超时时间，以便重启系统是可以进入grub2手动输入命令进行引导ISO镜像
    
    </summary>
    
    
      <category term="linux" scheme="https://jingniao.github.io/tags/linux/"/>
    
      <category term="iso" scheme="https://jingniao.github.io/tags/iso/"/>
    
      <category term="阿里云" scheme="https://jingniao.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>cas配置——service配置修改</title>
    <link href="https://jingniao.github.io/2017/12/30/cas-docker-config/"/>
    <id>https://jingniao.github.io/2017/12/30/cas-docker-config/</id>
    <published>2017-12-30T22:11:21.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因说明"><a href="#原因说明" class="headerlink" title="原因说明"></a>原因说明</h2><p>从<code>hub.docker.com</code>上下载的<code>cas</code>官方镜像我没找到比较好的更改配置（例如<code>更改service配置</code>）的方法，因为默认采用<code>maven</code>的<code>overlay</code>进行构建的，原谅我这个不太熟悉<code>java</code>生态的的弱渣</p><p>所以还是从官方的构建脚本来自行构建，官方推送到<code>hub.docker.com</code>的镜像好像进行了一定的清理，跟直接使用<code>Dockerfile</code>构建的还是有点差别的</p><p>所以我fork了官方库，对版本进行了固定，然后为了绕开国内在进行maven构建时抽风似的网速影响，选择了docker的自动构建<br><a id="more"></a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 8443:8443 jingniao/mycas:release-5.1.7 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入镜像中后，未指定目录一致为/cas-overlay 目录</span></span><br><span class="line"></span><br><span class="line">./build.sh gencert </span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成证书，原来的证书keystore是空的，不进行生成会启动报错，一个容器只需要运行一次</span></span><br><span class="line">./build.sh run # 重新进行war包构建以及启动java</span><br></pre></td></tr></table></figure><p>然后就可以使用<code>https://cas.example.org:8443/cas/login</code> 来进行登陆了<br>默认账户密码：<code>casuser::Mellon</code><br>可以在<code>application.properties</code>或者<code>cas.properties</code>里修改添加或者删除配置：<code>cas.authn.accept.users</code>，为了安全，一般寻找配置里的内容将静态用户密码认证禁用  </p><h3 id="更改cas服务器域名"><a href="#更改cas服务器域名" class="headerlink" title="更改cas服务器域名"></a>更改cas服务器域名</h3><p>请配置<code>hosts</code>或者<code>dns</code>，将<code>cas.example.org</code>指向docker主机所在的ip<br>如果需要更改<code>cas.example.org</code>为自定义的域名<code>xxx.xxx</code>，可以查看<code>build.sh</code>脚本里<code>gencert</code>生成的证书命令，然后在<code>cas.properties</code>里添加配置 <code>server.ssl.key-alias=xxx.xxx</code></p><h3 id="启用proxy模式服务"><a href="#启用proxy模式服务" class="headerlink" title="启用proxy模式服务"></a>启用proxy模式服务</h3><blockquote><p>这就需要修改<code>serivce配置</code>，而且如果需要<code>cas</code>的<code>proxy 代理模式</code>（<code>默认禁止</code>使用）需要修改<code>service</code>的配置</p></blockquote><p>因为不了解<code>java</code>的生态，对于<code>overlay</code>之前也没有了解过，到底怎么进行配置修改没有头绪，我看到cas教程中有些是提示将配置文件跟<code>service</code>配置文件丢到<code>/etc/cas/config</code> <code>/etc/cas/services</code>文件夹里</p><p>但经过我实验，<code>/etc/cas/config</code>的<code>cas.properties</code>配置文件是可以其一定作用的，在启用<code>initFromJson</code> 配置文件后，放在<code>/etc/cas/services</code>的json服务配置文件没有起作用？不太清楚是我哪里配置有问题还是其他原因，这部分浪费了不少时间</p><p>所以我选择了下面的方法，<br>设置<code>service</code>配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo "cas.serviceRegistry.initFromJson=true" &gt;&gt; /cas-overlay/etc/cas/config/cas.properties</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为下面的build.sh启动脚本会将/cas-overlay/etc/cas/config/cas.properties复制到/etc/cas/config/cas.properties，如果不适用build.sh脚本启动而是直接运行war包，则需要修改/etc/cas/config里的配置</span></span><br><span class="line">mkdir -p src/main/resources/services/</span><br><span class="line">cat src/main/resources/services/test-1001.json</span><br></pre></td></tr></table></figure></p><h1 id="设置json内容，已经启用proxy"><a href="#设置json内容，已经启用proxy" class="headerlink" title="设置json内容，已经启用proxy"></a>设置json内容，已经启用proxy</h1><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"@class"</span> : <span class="string">"org.apereo.cas.services.RegexRegisteredService"</span>,</span><br><span class="line">  <span class="attr">"serviceId"</span> : <span class="string">"^(https|imaps)://.*"</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"test"</span>,</span><br><span class="line">  <span class="attr">"id"</span> : <span class="number">1001</span>,</span><br><span class="line">  <span class="attr">"description"</span> : <span class="string">"test"</span>,</span><br><span class="line">  <span class="attr">"evaluationOrder"</span> : <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"allowedToProxy"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"proxyPolicy"</span> : &#123;</span><br><span class="line">    <span class="attr">"@class"</span> : <span class="string">"org.apereo.cas.services.RegexMatchingRegisteredServiceProxyPolicy"</span>,</span><br><span class="line">    <span class="attr">"pattern"</span> : <span class="string">"^https?://.*"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>evaluationOrder</code>是优先级，默认是有2个配置的，数值越小，优先级越高，如果定义了相同的<code>serviceId</code>，则会根据优先级高低进行选择<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh run</span><br></pre></td></tr></table></figure></p><p>进行overlay重新打包war，然后执行，会将src里目录的内容继承到cas.war文件里，达到修改配置的作用<br>如果有谁知道cas官方的docker镜像怎么修改service之类的配置，还请邮件通知我，感激不尽</p><p>到这里，cas server基本上可以使用了</p><p>到这里就可以允许https进行接入了</p><h3 id="接入proxy模式应用"><a href="#接入proxy模式应用" class="headerlink" title="接入proxy模式应用"></a>接入proxy模式应用</h3><p>proxy请求端的https是可以访问的，浏览器可以访问http页面，但是在请求proxy的时候，cas server会对应用的https地址进行回掉。所以这里的应用域名对于cas server应该也是可以访问的。</p><p>另外需要注意一点的是应用的https证书对cas server来说应该是“合法”的，可以是真正公网权威证书机构签发的https证书</p><p>也可以是上面gencert 时生成的证书进行签发，然后将gencert是也会在/etc/cas/目录生成thekeystore和cas.cer，将cas.cer这个ca证书导入到cas server的jre环境里(跟以前12306需要导入根证书一样的道理)，这样对cas server来说，proxy请求用用的https证书就合法了`</p><h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><ul><li>后端数据库，ldap之类的的接入</li><li>登陆界面的更改</li><li>推荐阅读 <a href="http://blog.csdn.net/u010475041/article/category/7156505" target="_blank" rel="noopener">悟空_</a> 的博客 以及他的 <a href="https://github.com/kawhii/sso" target="_blank" rel="noopener">github</a>，写了20篇的cas文章，感觉是个很厉害的人</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原因说明&quot;&gt;&lt;a href=&quot;#原因说明&quot; class=&quot;headerlink&quot; title=&quot;原因说明&quot;&gt;&lt;/a&gt;原因说明&lt;/h2&gt;&lt;p&gt;从&lt;code&gt;hub.docker.com&lt;/code&gt;上下载的&lt;code&gt;cas&lt;/code&gt;官方镜像我没找到比较好的更改配置（例如&lt;code&gt;更改service配置&lt;/code&gt;）的方法，因为默认采用&lt;code&gt;maven&lt;/code&gt;的&lt;code&gt;overlay&lt;/code&gt;进行构建的，原谅我这个不太熟悉&lt;code&gt;java&lt;/code&gt;生态的的弱渣&lt;/p&gt;
&lt;p&gt;所以还是从官方的构建脚本来自行构建，官方推送到&lt;code&gt;hub.docker.com&lt;/code&gt;的镜像好像进行了一定的清理，跟直接使用&lt;code&gt;Dockerfile&lt;/code&gt;构建的还是有点差别的&lt;/p&gt;
&lt;p&gt;所以我fork了官方库，对版本进行了固定，然后为了绕开国内在进行maven构建时抽风似的网速影响，选择了docker的自动构建&lt;br&gt;
    
    </summary>
    
    
      <category term="cas" scheme="https://jingniao.github.io/tags/cas/"/>
    
      <category term="docker" scheme="https://jingniao.github.io/tags/docker/"/>
    
      <category term="overlay" scheme="https://jingniao.github.io/tags/overlay/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记（二）</title>
    <link href="https://jingniao.github.io/2017/12/11/learn-one/"/>
    <id>https://jingniao.github.io/2017/12/11/learn-one/</id>
    <published>2017-12-11T20:56:21.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><ul><li>用户名 <code>&quot;/^[a-zA-Z][a-zA-Z0-9_]{5,15}$/&quot;</code> 字母开头，包含数字字母下划线 总长度为6-16位</li><li>用户姓名 <code>&quot;/^[\x{4e00}-\x{9fa5}A-Za-z0-9_@、.\[\]\&quot;:\-]{1,100}$/u&quot;</code> 中文，数字字母符号，1到100位</li><li>手机号 <code>&quot;/^[1]{1}[0-9]{10}$/&quot;</code> 以1开头，11位数字</li></ul><a id="more"></a><h2 id="mysql编码"><a href="#mysql编码" class="headerlink" title="mysql编码"></a>mysql编码</h2><ul><li>查看字符集 <code>show variables like &#39;%char%&#39;;</code><br><img src="/image/mysql_bianma.png" alt="&#39;mysql编码&#39;"><br><code>character_set_results</code>、<code>character_set_client</code> 、<code>character_set_connection</code> 这三者会被mysql配置文件里<code>[client]</code>里的<code>default-character-set</code>影响，也会被<code>set names utf8</code> 影响</li></ul><ul><li>mysql 5.5.3 版本之后支持<code>utf8mb4</code>，也就是支持4字节的utf8编码，目前常用的emoji字符有不少都是4字节的，目前支持utf8mb4编码的mysql驱动只有；[‘pymysql’, ‘mysqldb’]</li><li><p>如果要设置需要存储utf8mb4字符，可以进行如下设置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">character-set-server</span>=utf8mb4 </span><br><span class="line"><span class="comment"># 服务器默认编码，会影响新创建的数据库的编码，数据库的编码会影响新创</span></span><br><span class="line"><span class="comment"># 建的表的编码，表的编码一般是存储数据的事迹编码，当然还可以设置某列</span></span><br><span class="line"><span class="comment"># 的编码</span></span><br><span class="line"></span><br><span class="line"><span class="attr">collation-server</span> = utf8mb4_unicode_ci <span class="comment">#排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据语义，初始化链接的时候，执行某些语句</span></span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET NAMES utf8mb4'</span> </span><br><span class="line"><span class="attr">init_connect</span>=<span class="string">'SET collation_connection = utf8mb4_unicode_ci'</span></span><br><span class="line"><span class="attr">character-set-client-handshake</span>=<span class="literal">true</span> <span class="comment"># 忽略客户端的编码设置</span></span><br><span class="line"></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8mb4 <span class="comment"># 客户端默认编码设置</span></span><br><span class="line"><span class="comment"># 与 set names utf8mb4一样的想过</span></span><br></pre></td></tr></table></figure></li><li><p>如果有条件的话，还是将数据库设置为同一编码，数据库连接也设置位同一编码，否则有时候是自找麻烦</p></li></ul><h2 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h2><ul><li><code>flask</code>默认自带的<code>session</code>，是将数据加密存放在<code>client</code>端的<code>cookie</code>里的</li><li><code>python2</code> 中<code>flask</code>，<code>jinja2</code> 内容默认使用的都是<code>unicode</code>，在使用<code>jinja2</code>模板的时候，会将传入的<code>str</code>类型进行<code>decode(sys.getdefaultencoding)</code>操作，所以如果传入 <code>&#39;中文&#39;</code> 而不是 <code>u&#39;中文&#39;</code>，则j<code>inja2</code>会抛出异常</li><li><code>flask-sqlalchemy</code> 在使用<code>mysql</code>作为后端的时候，会自动添加<code>charset=utf8</code>参数，在某些编码情况下，会出现比较恼人的编码问题</li><li><code>sqlite3</code> 在存取数据只接受<code>unicode</code>，不接受<code>str</code>，mysql大部分驱动会接受<code>str</code>跟<code>unicode</code></li></ul><h2 id="pymysql-sqlalchemy"><a href="#pymysql-sqlalchemy" class="headerlink" title="pymysql/sqlalchemy"></a>pymysql/sqlalchemy</h2><p>为了保证数据库的中文编码正确，以下是几点建议：</p><ul><li>数据表字段的编码应该兼容中文的，例如<code>latin1</code>就不兼容<code>中文</code>，尽量不要使用这种编码，不是说一定不能用，如果禁止使用<code>mysql驱动</code>的<code>unicode</code>编码功能，在驱动外进行手动<code>encode</code> <code>decode</code>，传递给数据库直接是<code>str</code>，或者说是字节数组，还是可以得到正确的内容的，这就是所谓的错进错出了，但这时候因为数据库无法正确理解数据内容，也就无法正常排序查找了。</li><li>数据库连接字符集尽量使用与兼容中文的编码，例如<code>gbk</code>，<code>utf-8</code>，然后<code>python2</code>中输入给数据库的字符串使用<code>unicode</code>，不要使用<code>str</code>，让数据库驱动处理编码问题。</li><li>当<code>sqlalchemy</code>的<code>engine</code>的<code>url</code>有<code>charset</code>设置的时候，数据库驱动会默认使用<code>use_unicode=True</code>，这时候查询到的<code>orm</code>中的<code>String</code>类型，会以<code>unicode</code>返回，这点要注意，但是如果没有设置<code>charset</code>，在<code>python2</code>下<code>pymysql</code>中会将<code>charset</code>默认设置为<code>latin1</code>，然后<code>use_unicode</code>会被设置为<code>False</code>，这时会导致返回的<code>String</code>类型的数据为<code>python2</code>中的<code>str</code>，所以为了防止混乱，在<code>engine</code>创建的时候设置<code>charset</code>是一个比较好的选择</li><li><code>mysql</code>驱动<code>pymysql</code>对输入<code>str</code>跟<code>unicode</code>的处理差别：<code>pymysql/cursors.py Cursor._escape_args</code> 函数会进行参数编码检测，如果输入的参数是<code>unicode</code>类型的，则会调用<code>encode</code>使用连接编码进行编码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用户名 &lt;code&gt;&amp;quot;/^[a-zA-Z][a-zA-Z0-9_]{5,15}$/&amp;quot;&lt;/code&gt; 字母开头，包含数字字母下划线 总长度为6-16位&lt;/li&gt;
&lt;li&gt;用户姓名 &lt;code&gt;&amp;quot;/^[\x{4e00}-\x{9fa5}A-Za-z0-9_@、.\[\]\&amp;quot;:\-]{1,100}$/u&amp;quot;&lt;/code&gt; 中文，数字字母符号，1到100位&lt;/li&gt;
&lt;li&gt;手机号 &lt;code&gt;&amp;quot;/^[1]{1}[0-9]{10}$/&amp;quot;&lt;/code&gt; 以1开头，11位数字&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="sqlalchemy" scheme="https://jingniao.github.io/tags/sqlalchemy/"/>
    
      <category term="linux" scheme="https://jingniao.github.io/tags/linux/"/>
    
      <category term="mysql" scheme="https://jingniao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>pygame学习（一）</title>
    <link href="https://jingniao.github.io/2017/10/31/pygame-learn-one/"/>
    <id>https://jingniao.github.io/2017/10/31/pygame-learn-one/</id>
    <published>2017-10-31T15:12:51.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我的wp手机依然坚守在二线，虽然一般不玩游戏，但是实在是闲的时候也会尝试一些小游戏，而又有时候没有控制住的话，可能会非常沉迷。上一个沉迷的小游戏是<code>2048</code>，这次是消消乐。<br><a id="more"></a> </p><h2 id="规则说明："><a href="#规则说明：" class="headerlink" title="规则说明："></a>规则说明：</h2><ol><li>10 * 10 的方块空间，随机出现5种颜色，如果2个相同的方块相邻（上下左右四个方向），会将相连的相同颜色的块消除掉。</li><li>消除后，位于方块上方的方块会进行下落，如果某一列所有方块都被消除了，则位于该列右侧的所有方块会进行左移</li><li>计分规则为，每次消除方块的个数n，则该步得分为 n <em> n </em> 5</li><li>当所有方块都被消除或者，没有可以消除的方块的时候，游戏结束</li><li>未实现：原版中的如果将方块消除的剩余数目低于10个，则会有一定的积分奖励，最高为所有方块都被消除，会奖励2000分；关卡与道具是非必须的。  <h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2>这个项目放到了<a href="https://github.com/jingniao/gamelearn" target="_blank" rel="noopener">练习项目地址</a> <h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2></li><li>pygame.event的监听模型，目前常用的 get poll wait，wait是阻塞的，其他两个是非阻塞的。另外如果不想默认监听所有event的话可以使用<code>pygame.event.set_allowed</code>方法来设置需要监听的方法，因为event列表长度是有限的。</li><li>pygame.time.Clock，生成对象后可以使用tick(30)，来控制帧率，30表示每秒30帧</li><li>精灵(<code>pygame.sprite.Sprite</code>)与精灵组(<code>pygame.sprite.Group</code>)的使用，Group.update 会自动调用组内精灵的update方法，clear方法，用于清除指定<code>Surface</code>上一帧所画的精灵，默认输入2个参数，第一个是之前精灵在哪个<code>Surface</code>上画画的，第二个是背景<code>Surface</code>，举个例子：A是红色的Surface背景，B是蓝色的精灵，B在group里，调用group的clear时，会将之前B占A的地方涂抹成C相对应的颜色。有点类似蒙版的效果</li><li>判断相同色块使用基本的广度优先搜索</li></ol><h2 id="不足的地方"><a href="#不足的地方" class="headerlink" title="不足的地方"></a>不足的地方</h2><ol><li>算法效率有待提升，虽然对于这个小游戏以及得益于当前强大的计算机性能，这个小游戏运行起来基本不占用什么资源，但是代码一些部分写的还是有些粗放</li><li>没有中间动画，这个虽然不影响游戏结果，但是一个游戏怎么可以没有动画</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;我的wp手机依然坚守在二线，虽然一般不玩游戏，但是实在是闲的时候也会尝试一些小游戏，而又有时候没有控制住的话，可能会非常沉迷。上一个沉迷的小游戏是&lt;code&gt;2048&lt;/code&gt;，这次是消消乐。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="pygame" scheme="https://jingniao.github.io/tags/pygame/"/>
    
      <category term="消消乐" scheme="https://jingniao.github.io/tags/%E6%B6%88%E6%B6%88%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>从osd恢复mon数据</title>
    <link href="https://jingniao.github.io/2017/03/30/ceph-rebuild-mon-data-from-osds/"/>
    <id>https://jingniao.github.io/2017/03/30/ceph-rebuild-mon-data-from-osds/</id>
    <published>2017-03-30T21:15:34.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>之前手上的一个Ceph 0.94.9集群因为突然断电，三个MON都因为leveldb的问题而无法启动。</p><h1 id="已有的解决方案"><a href="#已有的解决方案" class="headerlink" title="已有的解决方案"></a>已有的解决方案</h1><ol><li><a href="http://ceph.com/planet/ceph-recover-a-rbd-image-from-a-dead-cluster/" target="_blank" rel="noopener">从已死的集群中恢复rbd镜像-ceph官方</a></li><li><a href="http://www.zphj1987.com/2016/09/20/Ceph%E7%9A%84Mon%E6%95%B0%E6%8D%AE%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/" target="_blank" rel="noopener">Ceph的Mon数据重新构建工具-张鹏</a> 或者   <a href="http://docs.ceph.com/docs/hammer/rados/troubleshooting/troubleshooting-mon/#recovery-using-osds" target="_blank" rel="noopener">官方的文档</a> 这两个是同一个方法</li></ol><p>我这里选择第二种</p><a id="more"></a> <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><code>ceph-objectstore-tool</code>是从osd收集mon相关数据，这个工具从Hammer(0.94系列)应该就在Ceph中默认安装，并且可以使用，但是收集mon数据的参数<code>--op update-mon-db</code>却是在<code>0.94.10</code>版本中才添加进去的<br><code>ceph-monstore-tool</code>工具也是在<code>0.94.10</code>版本中才开始添加到<code>Hammer</code>中的，并且默认没有安装，需要手动安装<code>ceph-test</code>包这个工具才有，并且在<code>0.94.10</code>版本中这个工具是无法使用的，因为<a href="https://github.com/ceph/ceph/pull/13605/files" target="_blank" rel="noopener">这个bug</a>，到目前为止(<code>2017-03-30</code>),这个PR还没有合并到Hammer分支，我已经编译好了的<code>ceph-monstore-tool</code>工具，在<a href="http://pan.baidu.com/s/1c1TvcL6" target="_blank" rel="noopener">http://pan.baidu.com/s/1c1TvcL6</a> 密码：<code>jjic</code></p><p>步骤跟张鹏教程基本上一致，只是有些参数可能不太一致</p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>这个脚本是对官方的那个类似的脚本的补充，官方的那个脚本好像有点问题<br>添加注释会让文章中的代码很难看，还有gist在这里：<a href="https://gist.github.com/jingniao/839c6fe3b635a90b0fcfafa19c1b1557" target="_blank" rel="noopener">gist代码</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MS=/tmp/mon-store</span><br><span class="line">KEYRING=/etc/ceph/ceph.client.admin.keyring</span><br><span class="line">FSID=12730f48-443f-4483-9231-545496c5973a</span><br><span class="line">MONID=new-test-3</span><br><span class="line">MONIP=192.168.213.133</span><br><span class="line">HOSTS="new-test-1 new-test-2"</span><br><span class="line">mkdir $MS</span><br><span class="line">for host in $HOSTS; do</span><br><span class="line">  rsync -avz $MS/ root@$host:$MS/</span><br><span class="line">  rm -rf $MS</span><br><span class="line">  ssh -t root@$host "for osd in /var/lib/ceph/osd/ceph-*; do    ceph-objectstore-tool --data-path \$osd --journal-path \$osd/journal --op update-mon-db --mon-store-path $MS; done"</span><br><span class="line">  rsync -avz root@$host:$MS/ $MS/</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">ceph-authtool $KEYRING --import-keyring /var/lib/ceph/mon/ceph*/keyring</span><br><span class="line">ceph-authtool $KEYRING -n client.admin --cap mon 'allow *' --cap osd 'allow *' --cap mds 'allow *'</span><br><span class="line">./ceph-monstore-tool $MS rebuild -- --keyring $KEYRING</span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdir /var/lib/ceph/mon/ceph-<span class="variable">$MONID</span> </span></span><br><span class="line">cp -ra $MS/store.db /var/lib/ceph/mon/ceph-$MONID/</span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /var/lib/ceph/mon/ceph-<span class="variable">$MONID</span>/<span class="keyword">done</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> touch /var/lib/ceph/mon/ceph-<span class="variable">$MONID</span>/sysvinit</span></span><br><span class="line">monmaptool --create --fsid $FSID --add $MONID $MONIP:6789  monmap</span><br><span class="line">ceph-mon -i $MONID --inject-monmap monmap</span><br><span class="line">service ceph start mon</span><br></pre></td></tr></table></figure></p><p>基本上就这些了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;p&gt;之前手上的一个Ceph 0.94.9集群因为突然断电，三个MON都因为leveldb的问题而无法启动。&lt;/p&gt;
&lt;h1 id=&quot;已有的解决方案&quot;&gt;&lt;a href=&quot;#已有的解决方案&quot; class=&quot;headerlink&quot; title=&quot;已有的解决方案&quot;&gt;&lt;/a&gt;已有的解决方案&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://ceph.com/planet/ceph-recover-a-rbd-image-from-a-dead-cluster/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;从已死的集群中恢复rbd镜像-ceph官方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zphj1987.com/2016/09/20/Ceph%E7%9A%84Mon%E6%95%B0%E6%8D%AE%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ceph的Mon数据重新构建工具-张鹏&lt;/a&gt; 或者   &lt;a href=&quot;http://docs.ceph.com/docs/hammer/rados/troubleshooting/troubleshooting-mon/#recovery-using-osds&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方的文档&lt;/a&gt; 这两个是同一个方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我这里选择第二种&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://jingniao.github.io/categories/linux/"/>
    
    
      <category term="shell" scheme="https://jingniao.github.io/tags/shell/"/>
    
      <category term="ceph" scheme="https://jingniao.github.io/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title>笔记学习（一）</title>
    <link href="https://jingniao.github.io/2017/03/21/learn-1/"/>
    <id>https://jingniao.github.io/2017/03/21/learn-1/</id>
    <published>2017-03-21T21:42:14.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一点点的记录</p><hr><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="查看现有内核启动顺序"><a href="#查看现有内核启动顺序" class="headerlink" title="查看现有内核启动顺序"></a>查看现有内核启动顺序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F\' '$1=="menuentry " &#123;print $2&#125;' /etc/grub2.cfg</span><br></pre></td></tr></table></figure><h3 id="设置默认启动项"><a href="#设置默认启动项" class="headerlink" title="设置默认启动项"></a>设置默认启动项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure><a id="more"></a> <h3 id="远程执行命令"><a href="#远程执行命令" class="headerlink" title="远程执行命令"></a>远程执行命令</h3><p>远程计算机名为：remote_host<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh remote_host hostname</span><br><span class="line">ssh -t remote_host "cd /tmp ; bash"</span><br></pre></td></tr></table></figure></p><p>参数：<code>-t</code>  如果命令执行依赖于某些环境变量，例如需要到某个文件夹下执行某些命令的时候需要加这个参数    </p><h3 id="局域网内影响ssh连接速度的参数："><a href="#局域网内影响ssh连接速度的参数：" class="headerlink" title="局域网内影响ssh连接速度的参数："></a>局域网内影响ssh连接速度的参数：</h3><p>配置：/etc/ssh/sshd_config<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i "s/#UseDNS yes/UseDNS no/g" /etc/ssh/sshd_config</span><br><span class="line">sed -i "s/GSSAPIAuthentication yes/GSSAPIAuthentication no/g" /etc/ssh/sshd_config</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></p><h3 id="查看操作系统支持的文件系统"><a href="#查看操作系统支持的文件系统" class="headerlink" title="查看操作系统支持的文件系统"></a>查看操作系统支持的文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/filesystems</span><br><span class="line">ls /lib/modules/$(uname -r)/kernel/fs</span><br></pre></td></tr></table></figure><p>这两条命令结合起来看，基本上就是当前支持的文件系统</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="os库"><a href="#os库" class="headerlink" title="os库"></a>os库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.path.isfile()<span class="comment"># 是否是文件</span></span><br><span class="line">os.path.exists()<span class="comment"># 文件或者文件夹是否存在</span></span><br></pre></td></tr></table></figure><h3 id="python的编码问题"><a href="#python的编码问题" class="headerlink" title="python的编码问题"></a>python的编码问题</h3><p>在python2中，<code>str</code>是<code>字节(ascii)</code>数组，<code>u&quot;&quot;</code>是unicode编码<br>在python3中，<code>str</code>是<code>unicode</code>编码，<code>b&quot;&quot;</code>是<code>字节</code>数组，类似2中的str<br>记住unicode转字节的时候是编码，字节数组转unicode的时候是解码，用另外一种解释就是字节数组就是类似与<code>摩尔斯</code>的长短，是没有意义的，只有人类经过<code>解码(decode)</code>才能理解，而人类的文字信息想要通过无线电等渠道发送的，需要按照一定的规范进行<code>编码(encode)</code>。<br>在使用或者编写的函数的时候一定注意它接收的参数类型以及返回的值的类型</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一点点的记录&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;linux&quot;&gt;&lt;a href=&quot;#linux&quot; class=&quot;headerlink&quot; title=&quot;linux&quot;&gt;&lt;/a&gt;linux&lt;/h2&gt;&lt;h3 id=&quot;查看现有内核启动顺序&quot;&gt;&lt;a href=&quot;#查看现有内核启动顺序&quot; class=&quot;headerlink&quot; title=&quot;查看现有内核启动顺序&quot;&gt;&lt;/a&gt;查看现有内核启动顺序&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;awk -F\&#39; &#39;$1==&quot;menuentry &quot; &amp;#123;print $2&amp;#125;&#39; /etc/grub2.cfg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;设置默认启动项&quot;&gt;&lt;a href=&quot;#设置默认启动项&quot; class=&quot;headerlink&quot; title=&quot;设置默认启动项&quot;&gt;&lt;/a&gt;设置默认启动项&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grub2-set-default 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="linux" scheme="https://jingniao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>sqlalchemy的使用（二），表间外键约束</title>
    <link href="https://jingniao.github.io/2016/11/27/sqlalchemy-use-many-to-one/"/>
    <id>https://jingniao.github.io/2016/11/27/sqlalchemy-use-many-to-one/</id>
    <published>2016-11-27T08:55:07.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前篇文章简单介绍了使用sqlalchemy的时候怎么建立数据库，创建数据映射表，初始化，以及简单的插入，删除，更新，查询操作。当然，查询包含的东西还有很多，其中的细节还有很多，这个在使用过程中会根据你的需求慢慢侧重不同的方向。<br>数据库使用中一个无法绕过的功能就是外键的使用，虽然很多人认为web应用中应该消除外键，减少依赖。在高并发的程序中，web应用确实可能为了性能增加冗余信息的方式消除外键，但是在普通的程序，数据库操作没有成为瓶颈的时候，外键能比较好的维护数据实体之间的关系，较少冗余。</p><a id="more"></a>  <h1 id="外键使用"><a href="#外键使用" class="headerlink" title="外键使用"></a>外键使用</h1><h2 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h2><p>接上篇的<code>Persion</code>，现在添加另外一个表，<code>Book</code>，一个<code>Persion</code>有多个<code>Book</code>，<code>Book</code>有一个外键auther_id，它指向Persion的id列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename = <span class="string">'book'</span></span><br><span class="line">    id = Column(Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name=Column(String(<span class="number">1024</span>))</span><br><span class="line">    auther_id = Column(Integer,ForeignKey(<span class="string">'persion.id'</span>))</span><br></pre></td></tr></table></figure></p><p>然后在<code>Persion</code>表中添加反向映射关系，让<code>Persion</code>能查询关联到它的<code>Book</code>，也让<code>Book</code>能查询到它归属的<code>Persion</code><br>在<code>Persion</code>中添加一个类属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">books = relationship(<span class="string">'Book'</span>,backref=<span class="string">'auther'</span>,lazy=<span class="string">"dynamic"</span>)</span><br></pre></td></tr></table></figure></p><p>books并不是可以实际输入的列，在创建Persion的时候不需要设置，只要在Book表中的有外键指向Persion表，则就可以通过books查询Book对象。<br>relationship，第一个参数是Book的类名，backref参数是给Book添加一个属性，在这个例子中Book.auther指向的是Persion，可以通过它来查询。<br>lazy则是加载方式，默认是select，是在查询books归属的Persion的时候就自动查询并加载books，也就是一次查询所有数据，这个例子中，设为dynamic是生成一个Query对象，但是还没有进行数据查询，可以使用类似与：per_obj.books.query(xxx).all()类似的语句对books进行二次过滤查询。</p><blockquote><p>值得一提的是，上面例子中backref向Book注入的auther的lazy属性默认是select，也就是在加载Book的结果的时候，也会顺便查询它归属的Persion</p></blockquote><h3 id="注意点说明"><a href="#注意点说明" class="headerlink" title="注意点说明"></a>注意点说明</h3><ul><li>一对多关系，外键在多的一方，relationship在一的一方。</li><li>lazy属性的设置需要根据需求来设置，如果每次查询Persion都需要获取Book，那默认值select是值得使用。</li><li>如果两个表是互相有外键字段指向对方，则relationship的lazy属性不能是默认值，需要是dynamic之类的动态加载，否则会造成查询的时候，循环引用的问题。也就是说外键关系是一个环的时候select是不合适的。</li><li>如果一个表有多个外键，指向不同的表的时候relationship除了第一个参数，映射类的名字外，还需要指定关联关系是怎么样的primaryjoin=’Persion.id==Book.auther_id’，类似的这样的关系。<h2 id="多对一关系"><a href="#多对一关系" class="headerlink" title="多对一关系"></a>多对一关系</h2>这种是外键关系跟relationship在同一个类定义中。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'parent'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    child_id = Column(Integer, ForeignKey(<span class="string">'child.id'</span>))</span><br><span class="line">    child = relationship(<span class="string">"Child"</span>, backref=<span class="string">"parents"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'child'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li></ul><p>官方给的例子是个。</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> backref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'parent'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    child_id = Column(Integer, ForeignKey(<span class="string">'child.id'</span>))</span><br><span class="line">    child = relationship(<span class="string">"Child"</span>, backref=backref(</span><br><span class="line">        <span class="string">"parent"</span>, uselist=<span class="literal">False</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'child'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>看上去是特殊的多对一，backref=backref(“parent”, uselist=False)是关键，将关系映射中，一的注入的属性原来是个列表的时候，uselist=False否认是一个列表。</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">association_table = Table(<span class="string">'association'</span>, Base.metadata,</span><br><span class="line">    Column(<span class="string">'left_id'</span>, Integer, ForeignKey(<span class="string">'left.id'</span>)),</span><br><span class="line">    Column(<span class="string">'right_id'</span>, Integer, ForeignKey(<span class="string">'right.id'</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'left'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    children = relationship(</span><br><span class="line">        <span class="string">"Child"</span>,</span><br><span class="line">        secondary=association_table,</span><br><span class="line">        back_populates=<span class="string">"parents"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'right'</span></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    parents = relationship(</span><br><span class="line">        <span class="string">"Parent"</span>,</span><br><span class="line">        secondary=association_table,</span><br><span class="line">        back_populates=<span class="string">"children"</span>)</span><br></pre></td></tr></table></figure><p>关键在于：relationship的back_populates，借助中间表来定义多对多。</p><blockquote><p>说明：工作中使用的最多的是一对多关系，多对多关系的我试验过，但是没用到，另外两种是官方给的例子。<br>工作中使用两个一对多，互相只想多方，如下面的例子：   </p></blockquote><h2 id="循环一对多关系"><a href="#循环一对多关系" class="headerlink" title="循环一对多关系"></a>循环一对多关系</h2><p>还是我自己写的Persion和Book关系，<code>一个人可能写过多本书，一本Book只有一个Persion写，N个人最喜欢1个书，每个人只能有一个最喜欢的</code>这个例子可能不大恰当，但是就是两个单向的一对多关系，是不能用多对多关系的，下面是我给出的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'persion'</span></span><br><span class="line">    id = Column(Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">1024</span>))</span><br><span class="line">    like_id = Column(Integer, ForeignKey(<span class="string">'book.id'</span>))</span><br><span class="line">    books = relationship(<span class="string">'Book'</span>, backref=<span class="string">'auther'</span>, lazy=<span class="string">"dynamic"</span>,</span><br><span class="line">                         primaryjoin=<span class="string">'Book.auther_id==Persion.id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'book'</span></span><br><span class="line">    id = Column(Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    likes = relationship(<span class="string">'Persion'</span>, backref=<span class="string">'like'</span>, lazy=<span class="string">"dynamic"</span>,</span><br><span class="line">                         primaryjoin=<span class="string">'Persion.like_id==Book.id'</span>)</span><br><span class="line">    name = Column(String(<span class="number">1024</span>))</span><br><span class="line">    auther_id = Column(Integer, ForeignKey(<span class="string">'persion.id'</span>))</span><br></pre></td></tr></table></figure><p>主要是添加primaryjoin属性，说明关联的字段</p><p>在使用sqlalchemy的时候有很多属性，类似lazy，backref，primaryjoin这样的属性，备选项很多，需要多多查询官方文档。只有使用过过才会比较熟悉</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前篇文章简单介绍了使用sqlalchemy的时候怎么建立数据库，创建数据映射表，初始化，以及简单的插入，删除，更新，查询操作。当然，查询包含的东西还有很多，其中的细节还有很多，这个在使用过程中会根据你的需求慢慢侧重不同的方向。&lt;br&gt;数据库使用中一个无法绕过的功能就是外键的使用，虽然很多人认为web应用中应该消除外键，减少依赖。在高并发的程序中，web应用确实可能为了性能增加冗余信息的方式消除外键，但是在普通的程序，数据库操作没有成为瓶颈的时候，外键能比较好的维护数据实体之间的关系，较少冗余。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="sqlalchemy" scheme="https://jingniao.github.io/tags/sqlalchemy/"/>
    
      <category term="sql" scheme="https://jingniao.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>sqlalchemy的使用（一）——初始化以及简单使用</title>
    <link href="https://jingniao.github.io/2016/11/26/sqlalchemy-use-start/"/>
    <id>https://jingniao.github.io/2016/11/26/sqlalchemy-use-start/</id>
    <published>2016-11-26T11:55:11.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习并在工作中使用python的时间并不长，<code>django</code>的使用只能说用到的功能比较熟悉而已。并且工作中使用的并没有使用太多插件。只是将<code>django</code>作为一个请求接受以及返回格式化数据的东西。<br>之前使用到了数据库，使用的是django自带的orm框架，有点是简单，并且在django中使用方便。最近需要在django外的独立程序中使用数据库，虽然有方法使用django的orm，但是毕竟隔了一层，不太方便移植的特点，让我开始学习<code>sqlalchemy</code>这个大名鼎鼎的python数据库框架。以下就是我遇到的几个坑，应该是比较基础的，记录下。</p><a id="more"></a> <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="类映射"><a href="#类映射" class="headerlink" title="类映射"></a>类映射</h2><p>这里的一个类映射到数据库中是一个表<br>db.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span><span class="params">(Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'persion'</span></span><br><span class="line">    id = Column(Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>) </span><br><span class="line">    name = Column(String(<span class="number">1024</span>))</span><br></pre></td></tr></table></figure><p>除了<code>String</code>,<code>Integer</code>，还有其他类型，类型数量很多<br><code>Column</code>的的第一个参数是数据表中的列名，可以省略，当省略的时候，将这个类变量的名字作为数据表中的列名。<br>访问<code>Persion.id</code>访问的是<code>persion</code>表中的<code>id</code>列</p><h2 id="数据表初始化，以及简单查询"><a href="#数据表初始化，以及简单查询" class="headerlink" title="数据表初始化，以及简单查询"></a>数据表初始化，以及简单查询</h2><h3 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h3><p>初始化放到另外一个文件:<br>client.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> db <span class="keyword">import</span> Persion,Base</span><br><span class="line"></span><br><span class="line">db_path = <span class="string">"sqlite:///database.db"</span></span><br><span class="line">engine = create_engine(db_path)  <span class="comment">#创建连接引擎</span></span><br><span class="line"></span><br><span class="line">Base.metadata.reflect(engine)  <span class="comment"># 将数据映射绑定到引擎</span></span><br><span class="line">Base.metadata.create_all(engine)  <span class="comment"># 创建所有映射表</span></span><br></pre></td></tr></table></figure></p><p>如果有多个类似与<code>db.py</code>文件，需要一起进行初始化的话，只要引用的是同一个<code>Base</code>实例，运行<code>create_all()</code>时类已经被导入，则可以一起初始化。   </p><blockquote><p>上述例子中<code>db_path</code>是数据库连接地址，这里只是sqlite简单的例子，如果是其他的类似<code>mysql</code>，<code>postgresql</code>等例子，会包含数据库名，驱动名，用户，密码，数据库名，<a href="http://docs.sqlalchemy.org/en/latest/core/engines.html" target="_blank" rel="noopener">官方说明</a></p></blockquote><h3 id="插入数据库"><a href="#插入数据库" class="headerlink" title="插入数据库"></a>插入数据库</h3><p>接着上节的<code>client.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Session = sessionmaker()</span><br><span class="line">Session.configure(bind=engine)</span><br><span class="line">session = Session() <span class="comment">#然后就可以使用session进行查询操作了</span></span><br><span class="line"></span><br><span class="line">persion_obj = Persion(id=<span class="number">1</span>,name=<span class="string">'jingniao'</span>)</span><br><span class="line">session.add(persion_obj)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><h3 id="数据库连接进行查询"><a href="#数据库连接进行查询" class="headerlink" title="数据库连接进行查询"></a>数据库连接进行查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query = session.query(Persion)</span><br><span class="line">result = query.all()</span><br></pre></td></tr></table></figure><p>解释：<br><code>query</code>是一个<code>sqlalchemy.orm.query.Query</code> object，代表的是一个查询操作。上面的例子是返回<code>Persion</code>的所有例子，如果数据表里有内容的话，会返回所有内容，类似与<code>select * from persion;</code>，不加过滤条件。<br>如果要加过滤条件的话，可以添加<code>filter</code>，filter返回的也是一个<code>Query</code>对象，也就是说可以跟多个<code>filter</code>，进行链式调用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query = session.query(Persion).filter(Persion.id==<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p><code>Query</code>除了进行<code>filter</code>进行查询过滤外还有其他方法：<br><code>all</code> 返回所有的查询结果，是一个List,列表项是查询的对象实例，例如上面的例子中是Persion的实例<br><code>first</code> 返回的是所查询结果集的第一个实例<br><code>update</code> 更新数据操作，参数类似于<code>query</code>方法的参数<br><code>delete</code> 删除操作，将查询到的数据集删除  </p><p>除了上面的<code>update</code>操作，对于<code>all</code>返回的对象列表中的值或者<code>first</code>返回的对象来说，直接更改实例的属性的值也可以达到同样的效果<br>上述更改操作（<code>update</code>，或者更改对象属性），删除操作(<code>delete</code>)，添加记录(<code>add</code>)，都需要对<code>session</code>进行<code>commit</code>操作（事物提交）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="结果转化"><a href="#结果转化" class="headerlink" title="结果转化"></a>结果转化</h3><p>在<code>django</code>的orm使用中，对结果集，有自带的values_list方法将结果转化成python的字典列表格式，方便手动输出json或者还有设置序列化直接输出json的。<br><code>sqlalchemy</code>中好像就没那么方便的感觉（可能还有其他方法比较简便的就不清楚了），下面是一种方法：<br>在db.py文件中，定义Base的派生类前添加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_dict</span><span class="params">(self)</span>:</span></span><br><span class="line">    out = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns:</span><br><span class="line">        out[c.name] = getattr(self, c.name, <span class="literal">None</span>)  </span><br><span class="line">        <span class="comment"># c.name获取的是数据表中的列名，self中可能没有这个列名对应的属性</span></span><br><span class="line">Base.to_dict = to_dict</span><br></pre></td></tr></table></figure></p><p>然后在<code>client.py</code>中使用查询结果的时候，需要转换成字典列表的形式的时候可以对result进行操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result_list = [per.to_dict() for per in result]</span><br></pre></td></tr></table></figure></p><p>当然也可以对<code>to_dict</code>函数添加参数用于过滤或者其他控制，这个就不说了。</p><blockquote><p>注意：这个函数只在映射类的属性名与表中的列名一致的情况下使用，如果不一致是无法获取数据的。</p></blockquote><p>一个键如果是<code>Integer</code>,可以设置字段自增，类似于1 2 3 4，同时可以设置主键，在使用自增id的时候可能会用到<br>给Persion增加属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id = Column(Integer, autoincrement=<span class="literal">True</span>, primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><p>其他Column的参数：<br><code>nullable</code>=<code>False</code> or <code>True</code>  是否非空，默认是<code>True</code>。在sql 中转换成<code>NOT NULL</code> or  <code>NULL</code><br><code>default</code> 设置默认值，<code>sqlalchemy</code>没有将默认值约束写入到数据库中，因为默认值可以是表达式，需要在python中计算  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;学习并在工作中使用python的时间并不长，&lt;code&gt;django&lt;/code&gt;的使用只能说用到的功能比较熟悉而已。并且工作中使用的并没有使用太多插件。只是将&lt;code&gt;django&lt;/code&gt;作为一个请求接受以及返回格式化数据的东西。&lt;br&gt;之前使用到了数据库，使用的是django自带的orm框架，有点是简单，并且在django中使用方便。最近需要在django外的独立程序中使用数据库，虽然有方法使用django的orm，但是毕竟隔了一层，不太方便移植的特点，让我开始学习&lt;code&gt;sqlalchemy&lt;/code&gt;这个大名鼎鼎的python数据库框架。以下就是我遇到的几个坑，应该是比较基础的，记录下。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="sqlalchemy" scheme="https://jingniao.github.io/tags/sqlalchemy/"/>
    
      <category term="sql" scheme="https://jingniao.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>小python程序——hexo用户统计</title>
    <link href="https://jingniao.github.io/2016/07/24/user-statistics-by-openshift/"/>
    <id>https://jingniao.github.io/2016/07/24/user-statistics-by-openshift/</id>
    <published>2016-07-24T21:42:17.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>hexo挂着也有一段时间了，刚刚折腾的时候，也是有不少问题，现在再去整这些东西就轻车熟路了吧，之前还开过disqus评论，但是感觉没什么用，所以就关掉了，现在这个主题，作者已经不怎么更新了，所以有问题或者想要加什么东西就需要自己琢磨了。<br><a id="more"></a></p><h1 id="最近的折腾"><a href="#最近的折腾" class="headerlink" title="最近的折腾"></a>最近的折腾</h1><h2 id="html5的进击"><a href="#html5的进击" class="headerlink" title="html5的进击"></a>html5的进击</h2><p>周六的时候，虽然去漫展转了三个钟头，也是累的不轻，但是回来之后，还是继续周五晚上的活。当前这个主题在firefox的安卓下的js弹出有问题，点击左上角出来个人介绍之类的东西，再点击右边空白处，这个抽屉效果就会进去，但是在firefox的安卓浏览器上，弹不回去了。</p><p>最后找到问题，是因为代码里监听的触摸事件是<code>webkitTransitionEnd</code>，这是chrome系的事件，在firefox中是不起作用的。在正式的html5标准里，firefox和chrome都支持了<code>transitionend</code>事件。换成这个，然后再将<code>-webkit-transform</code>和<code>-webkit-transition</code>相应的位置添加对应的<code>transform</code>和<code>transition</code>。虽然替换了之后firefox的安卓版效果跟chrome系的还是有点差别，主要是弹出来的时候过度动画没有效果。但是好歹是能出来进去了。<br>从这里可以开出标准化的过程中也是有不少遗留的坑的。</p><h2 id="用户访问统计"><a href="#用户访问统计" class="headerlink" title="用户访问统计"></a>用户访问统计</h2><p>虽然没什么人在访问，评论也关闭了，但是还是想知道我的这个小的博客到底有没有人在访问，以及基于某种小心思，所以今天一天都耗在了这个上面。<br>技术选型：</p><ul><li>flask</li><li>openshift</li><li>mysql</li></ul><p>具体的思路：</p><ol><li>客户端使用jsonp向统计方发送一个请求。  </li><li>统计方获取当前页面的view（6小时内的请求，同一个ip算同一次view）。如果没有这个页面的view，则设为1，记录该ip访问该页面时间。</li><li>判断6小时内是否这个ip已经访问过这个页面<br> 1) 如果没有访问过，记录该ip访问这个页面的时间<br> 2) 如果已经访问过，超过6小时，更新访问时间，view + 1 返回，6小时以内，访问过，则直接返回上一步获取的view  </li></ol><p>应该说是一个很简单的流程，这一天一直解决各种问题。遇到的问题列表</p><ul><li>openshift平台获取真实ip，request的<code>remote_addr</code>获取到的是内网ip。需要获取<code>header</code>里的<code>x-forwarded-for</code></li><li>mysql操作参数，python安装mysql连接包<code>mysql-python</code>有点小问题。但是也耗费了不少时间</li><li>jsonp的使用，flask返回什么样的值，对于我这种只返回过json的值，jsonp应该返回什么值就有点抓瞎了。<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3>虽然只是一个很简单的小程序，但是还是提交到git了。<br><a href="http://git.oschina.net/zaita/statistics" target="_blank" rel="noopener">http://git.oschina.net/zaita/statistics</a><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1>应该说还是写得程序太少，今天遇到的问题在没有动手实际操作过之前，是不知道的，只有多写些程序才能够发现问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;hexo挂着也有一段时间了，刚刚折腾的时候，也是有不少问题，现在再去整这些东西就轻车熟路了吧，之前还开过disqus评论，但是感觉没什么用，所以就关掉了，现在这个主题，作者已经不怎么更新了，所以有问题或者想要加什么东西就需要自己琢磨了。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="hexo" scheme="https://jingniao.github.io/tags/hexo/"/>
    
      <category term="openshift" scheme="https://jingniao.github.io/tags/openshift/"/>
    
  </entry>
  
  <entry>
    <title>在vscode使用ptvsd进行远程python调试</title>
    <link href="https://jingniao.github.io/2016/07/21/python-remote-debug-by-ptvsd/"/>
    <id>https://jingniao.github.io/2016/07/21/python-remote-debug-by-ptvsd/</id>
    <published>2016-07-21T21:58:58.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调试python代码"><a href="#远程调试python代码" class="headerlink" title="远程调试python代码"></a>远程调试python代码</h1><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><p>随着python的学习的进步，经常需要进行代码调试，在使用print打印出变量这种方法不是很灵花的情况下，使用pdb进行断点调试已经是比较熟练了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line">pdb.settrace()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这种方法的好处是能够能够根据情况进行断点执行命令，虽然对有些命令的支持不是很好，但是单步执行，函数跳入之类的都是没有问题的。在使用django开发的时候经常使用这种方法来进行调试。</p><h2 id="使用ide的远程调试"><a href="#使用ide的远程调试" class="headerlink" title="使用ide的远程调试"></a>使用ide的远程调试</h2><p>pydev跟pycharm都提供了远程调试，但是说实话，做python的时间也算不太短了，pycharm一直使用的是社区版的，没有远程调试，pydev的远程调试没有使用成功。倒是今天接触的ptvsd使用成功了。</p><h2 id="ptvsd"><a href="#ptvsd" class="headerlink" title="ptvsd"></a>ptvsd</h2><p>这个原来是在vs上的python工具，远程调试也支持，现在vscode也开源不短时间了，vscode的python插件支持ptvsd进行远程调试。  </p><h3 id="设置vscode调试"><a href="#设置vscode调试" class="headerlink" title="设置vscode调试"></a>设置vscode调试</h3><p>在python代码里，点击debug的设置按钮会生成当前工作区的一个debug设置配置文件，里面有几个debug配置，如果要使用远程debug，其他几个可以不要的，将下面的配置文件放到原来配置文件同级别的地方：<br><img src="/image/vscode-debug.png" alt="&#39;vscode设置debug&#39;"><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"remote"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: <span class="string">"attach"</span>,</span><br><span class="line">    <span class="attr">"localRoot"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">    <span class="attr">"remoteRoot"</span>: <span class="string">"/root/temp"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"secret"</span>: <span class="string">"my_secret"</span>,</span><br><span class="line">    <span class="attr">"host"</span>:<span class="string">"192.168.136.129"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>remoteRoot是远程代码所在的位置<br>host 是远程地址</p><p>然后在代码开头添加几行代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ptvsd</span><br><span class="line">ptvsd.enable_attach(<span class="string">"my_secret"</span>, address=(<span class="string">'0.0.0.0'</span>, <span class="number">3000</span>))</span><br></pre></td></tr></table></figure></p><p>保持本地代码于远程代码一致，然后ssh到远程主机，执行python脚本。<br>我在vscode的python组件的github库里只看到这两句，实际上只有它的时候，会造成，执行debug的时候，没有停止，vscode连接不到远程，而是一路执行到程序结尾。<br><a href="https://blog.jamespan.me/2016/06/30/remote-debug-python-with-vscode/" target="_blank" rel="noopener">JamesPan的博客-python远程调试</a>  就是这样，但是这位老兄的代码是在一个循环里执行一些代码，然后每次循环sleep 1秒，相比开始的时候也遇到了这个问题。<br>后来我加了几行代码，就可以正常调试了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptvsd.wait_for_attach() </span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>wait_for_attach 这行代码的作用是，将远程进程卡住，等到vscode开始连接远程python代码的时候才会继续执行<br>import time<br>wait_for_attach后，vscode执行remote debug后，能收到远程代码执行的结果，输出也重定向到了本地，但是在vscode添加的断点就没有起作用。在sleep之后，发现正常停在了断点处。不清楚是ptvsd和vscode本身的缺陷还是其他的什么问题。</p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><p>大家看上面的操作大概就看出来了，远程调试每次开始调试的时候都需要到远程执行python脚本，而执行脚本完成之后，再点击vscode的debug按钮就连接不到远程debug（运行python的节点）了。这样看并没有比pdb方式方便太多的感觉。</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>适用于纯后台python程序的调试，比pdb方便的地方在虽然每次都需要执行脚本，但是可以比较方便的设置断点来执行。<br>还有另外一种情况就是查看远程python的后端程序输出（也可以重定向啊……）<br>至于上面仁兄那位的文章里介绍的保持远程于本地一致的pythong环境，然后可以调试第三方引用库，还没搞出来。这样看来，这个ptvsd对于vscode还是比较简陋的了，希望以后工作中，什么场景中会使用到这种远程调试。继续努力吧。</p><h2 id="我理想中的python远程调试"><a href="#我理想中的python远程调试" class="headerlink" title="我理想中的python远程调试"></a>我理想中的python远程调试</h2><p>跟sftp，ssh进行结合，然后，保持本地代码于远程一致，然后，其他的就像在本地debug一样方便，那就逆天了啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;远程调试python代码&quot;&gt;&lt;a href=&quot;#远程调试python代码&quot; class=&quot;headerlink&quot; title=&quot;远程调试python代码&quot;&gt;&lt;/a&gt;远程调试python代码&lt;/h1&gt;&lt;h2 id=&quot;普通方法&quot;&gt;&lt;a href=&quot;#普通方法&quot; class=&quot;headerlink&quot; title=&quot;普通方法&quot;&gt;&lt;/a&gt;普通方法&lt;/h2&gt;&lt;p&gt;随着python的学习的进步，经常需要进行代码调试，在使用print打印出变量这种方法不是很灵花的情况下，使用pdb进行断点调试已经是比较熟练了：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pdb.settrace()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="vscode" scheme="https://jingniao.github.io/tags/vscode/"/>
    
      <category term="remote-debug" scheme="https://jingniao.github.io/tags/remote-debug/"/>
    
  </entry>
  
  <entry>
    <title>atom使用</title>
    <link href="https://jingniao.github.io/2016/07/21/atom-use/"/>
    <id>https://jingniao.github.io/2016/07/21/atom-use/</id>
    <published>2016-07-21T07:26:22.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始使用atom"><a href="#开始使用atom" class="headerlink" title="开始使用atom"></a>开始使用atom</h1><p>前几天使用了vscode这个微软出品的atom芯的编辑器，应该说限制有点大，但是工作中使用时没有问题的，只是希望提高sftp插件的水平，现在动不动就卡死有点受不了。<br>然后我就开始尝试着使用atom这款github出品的编辑器。感觉就是另一种了，首先，两者的方向就不大一致。atom的目标是自由，按照网友的说法是，基本上所有的组建都是可以调整的。并且atom更新也比vscode勤快，插件数量，尤其是同类插件数量上，也比vscode强了好多。<br><a id="more"></a> </p><h2 id="常用的插件"><a href="#常用的插件" class="headerlink" title="常用的插件"></a>常用的插件</h2><ul><li>atom-beautify 格式化代码，支持的代码数量非常多，经实验，python的支持也算完善了。</li><li>autocomplete-python python的自动补全工具，应该说，还是挺智能的，也能搜索到所有本地文件里的类之类的。</li><li>script 简单的运行python脚本，应该是差不多了</li><li>linter-pep8 linter-pylint，pep8的检查只是检查pep8的风格，只要程序风格对了，其他的不管。pylint的检查则要精细化好多，检查的项目也多了好多，例如变量常量命名，未使用变量之类的都会进行一些语义的检查。坏处是对于代码引用的时候判断，如果不设置环境变量，则一般是找不到，还有检查项细致了太多，如果想要用好，配置可能比较麻烦。</li><li>simplified-chinese-menu 中文化插件，将大部分的核心菜单都翻译成了中文。看着顺眼了不少。</li><li>remote-ftp 必不可少的sftp同步插件，比vscode的同步插件靠谱了好多，而且atom给了更大的自由度，所以菜单里有同步选项了。</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开始使用atom&quot;&gt;&lt;a href=&quot;#开始使用atom&quot; class=&quot;headerlink&quot; title=&quot;开始使用atom&quot;&gt;&lt;/a&gt;开始使用atom&lt;/h1&gt;&lt;p&gt;前几天使用了vscode这个微软出品的atom芯的编辑器，应该说限制有点大，但是工作中使用时没有问题的，只是希望提高sftp插件的水平，现在动不动就卡死有点受不了。&lt;br&gt;然后我就开始尝试着使用atom这款github出品的编辑器。感觉就是另一种了，首先，两者的方向就不大一致。atom的目标是自由，按照网友的说法是，基本上所有的组建都是可以调整的。并且atom更新也比vscode勤快，插件数量，尤其是同类插件数量上，也比vscode强了好多。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="atom" scheme="https://jingniao.github.io/tags/atom/"/>
    
  </entry>
  
  <entry>
    <title>vscode使用感官</title>
    <link href="https://jingniao.github.io/2016/07/18/vscode-use/"/>
    <id>https://jingniao.github.io/2016/07/18/vscode-use/</id>
    <published>2016-07-18T21:45:03.000Z</published>
    <updated>2019-08-06T01:12:29.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开始使用vscode"><a href="#开始使用vscode" class="headerlink" title="开始使用vscode"></a>开始使用vscode</h1><p>vscode 是一款完成度较高的编辑器，经过插件配置之后，可以替代一部分ide的工作，对于常用的代码编写工作有比较大的帮助，现在我已经开始尝试着脱离sublime text的编写了，虽然sublime text的成熟度较高，插件也非常丰富。但是原生没有中文感觉有点不爽，虽然英文没有什么不明白的，python的自动补全功能差了点。<br><a id="more"></a><br>在vscode刚开源的时候，使用过一段时间的vscode，应该说，那时候感觉还不行，也没有方便的插件来进行开发，这样的编辑器顶多是一个好看的记事本而已，而且那时候还没有工作，对这方面的工具要求也不高，最开始学校的时候用notepad++最多，毕竟绿色化的东西好用了不少，ide用的也不多，工作之后使用sublime text用的比较多，并且一直是主力。但是最近因为各种原因，试了试一些其他的工具，vscode就进入了我的眼中。  </p><p>虽然以前对于微软的东西不是很感冒，vc也装过，但是基本上没有用过。对于c#这种语言来说，我本人是有偏见的，所以开发方面离微软就更远了。但是最近开始使用这个vscode感觉已经很不错了，虽然还差了那么一点点，但是已经可以作为一个轻量级的软件开发来使用了。</p><h2 id="python-的体验"><a href="#python-的体验" class="headerlink" title="python 的体验"></a>python 的体验</h2><p>vscode的python插件应该说给了我很好的体验，在win10系统中，配置并不复杂。虽然距离ide的开箱即用还差了一点，但是已经是非常不错的样子了，至少自动补全，代码格式化之类的只需要简单的配置而已，熟悉之后就很方便了。有点不方便的就是配置项的说明还差了点，不过这也不算什么不方便，熟悉之后就知道自己要做什么了，经常用的配置项保存一份，很容易了。</p><p>python的代码补全体验很好，比sublime好用一些。当然跟pycharm之类的专业ide还差了一点，这也是没有办法的，毕竟只是个编辑器而已。</p><h2 id="代码调试与上传"><a href="#代码调试与上传" class="headerlink" title="代码调试与上传"></a>代码调试与上传</h2><p>虽然对于大部分小的python代码，用于验证的话，在win10下的本地进行执行已经是比较方便了。但是一般来说的工作流程是，从内网服务器git到代码，然后使用这个编辑器将代码同步到本地计算机，使用vscode或者sublime进行编辑，编辑时自动上传到服务器，然后再服务器进行调整。   </p><p>虽然low了点，没有远程调试这种杀器，但是普通的项目基本上够用了，这样就需要一款同步软件了，在sublime下是sftp插件，总的来说已经是比较好用了，成熟度比较高，但是在大项目的上传下载速度较慢，vscode里只有一个ftp插件，强项是上传下载速度是很快的，但是，最近最新版本的vscode跟ftp插件兼容性差了点，经常远端的代码是一个较大的git库的时候，经常性的卡死在开始同步前，还有一点就是这个ftp插件的代码维护速度好像差了点，对bug修复不是很快，而且也没有替代的插件，不想sublime理搜sftp一堆插件等着用。</p><h2 id="有趣的功能"><a href="#有趣的功能" class="headerlink" title="有趣的功能"></a>有趣的功能</h2><ul><li>汉化，原生支持中文，菜单里的中文基本上都有，插件没有</li><li>markdown，能够预览，对写文档有帮助</li><li>方便的分栏，而且默认就各种分栏，常用就三栏</li><li>代码搜索很强大，发现代码分析之类的借助这个挺好用的</li></ul><h2 id="不方便的地方"><a href="#不方便的地方" class="headerlink" title="不方便的地方"></a>不方便的地方</h2><ul><li>markdown预览不会自动滚动到最新，编辑一屏之后，就看不到最新的了。</li><li>好像是没有开放api的样子，现在插件都是通过命令行来进行调用的，想sublime的右键点击出现命令调用的好像没有 </li><li>什么时候能够有个pycharm之类的代码动态检查功能（导入库，变量未定义检查之类的），就逆天了，虽然可能性不大。</li></ul><h2 id="希望改进的地方"><a href="#希望改进的地方" class="headerlink" title="希望改进的地方"></a>希望改进的地方</h2><ul><li>常用插件的改善，例如ftp</li></ul><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开始使用vscode&quot;&gt;&lt;a href=&quot;#开始使用vscode&quot; class=&quot;headerlink&quot; title=&quot;开始使用vscode&quot;&gt;&lt;/a&gt;开始使用vscode&lt;/h1&gt;&lt;p&gt;vscode 是一款完成度较高的编辑器，经过插件配置之后，可以替代一部分ide的工作，对于常用的代码编写工作有比较大的帮助，现在我已经开始尝试着脱离sublime text的编写了，虽然sublime text的成熟度较高，插件也非常丰富。但是原生没有中文感觉有点不爽，虽然英文没有什么不明白的，python的自动补全功能差了点。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="vscode" scheme="https://jingniao.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>使用git@osc的hook功能自动部署</title>
    <link href="https://jingniao.github.io/2016/05/19/hexo-git-hook-deploy/"/>
    <id>https://jingniao.github.io/2016/05/19/hexo-git-hook-deploy/</id>
    <published>2016-05-19T19:18:54.000Z</published>
    <updated>2019-08-06T01:12:29.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>git@osc的hook功能能够在推代码的时候进行post http请求，所以，做了小程序，来让我的博客自动更新更新github page的项目的一个东西，应该说，项目是很简单的。<br>项目分为两个部分，一部分是web部分，使用flask来接收来自git@osc的webhook，一部分做调用系统的hexo命令来进行更新操作。<br><a id="more"></a> </p><h1 id="实现逻辑说明"><a href="#实现逻辑说明" class="headerlink" title="实现逻辑说明"></a>实现逻辑说明</h1><p>因为webhook的超时时间是5s，所以，flask项目的作用就是一个触发器，接收到请求后，通过redis来发送消息给另外一个守护进程。<br>flask相关的核心代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">rd = redis.StrictRedis(host=<span class="string">"localhost"</span>)</span><br><span class="line">data = request.form[<span class="string">'hook'</span>]</span><br><span class="line">password = json.loads(data)[<span class="string">'password'</span>]</span><br><span class="line">rd.publish(<span class="string">"hexo"</span>, <span class="string">"hexo"</span>)</span><br></pre></td></tr></table></figure></p><p>另一个守护进程收到之后，进入到git@osc，执行三个操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> commands</span><br><span class="line">commands.getoutput(<span class="string">"git pull"</span>)</span><br><span class="line">commands.getoutput(<span class="string">"hexo g"</span>)</span><br><span class="line">commands.getoutput(<span class="string">"hexo d"</span>)</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个流程很简单，只有两步。要学会使用编程解决一些小问题，这就是一个很好的例子，虽然代码很少，但是能很好的学习python</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;git@osc的hook功能能够在推代码的时候进行post http请求，所以，做了小程序，来让我的博客自动更新更新github page的项目的一个东西，应该说，项目是很简单的。&lt;br&gt;项目分为两个部分，一部分是web部分，使用flask来接收来自git@osc的webhook，一部分做调用系统的hexo命令来进行更新操作。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>matplotlib简单画图并输出中文</title>
    <link href="https://jingniao.github.io/2016/04/30/matplotlib-zh-labels/"/>
    <id>https://jingniao.github.io/2016/04/30/matplotlib-zh-labels/</id>
    <published>2016-04-30T16:29:42.000Z</published>
    <updated>2019-08-06T01:12:29.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为个人非常想要学习机器学习，但是python关于机器学习到一些相关库都不熟悉，那就需要了解python相关到库，numpy是基础，matplotlib是显示相关的库，也得知道，所以开始学习matplotlib画图了。<br>本篇文章主要是简单的使用matplotlib画出一副简单的图片，然后添加一个中文标题<br><a id="more"></a> </p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>如果要在画的图中需要用中文进行标记的话，默认中文是不能正常显示的，目前中文毕竟不算强势语言，在编程界更弱势，因为中文而引起的编程上的问题一直在困扰这我们，编码，字体等问题你可以解决它，但无法无视它。 </p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>ubuntu 16.04 64bit<br>anaconda 4.0 python 3.5.2<br>matplotlib 1.5.1</p><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><p>以下程序代码（仅片段）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">zhfont = mpl.font_manager.FontProperties(</span><br><span class="line">    fname=<span class="string">'/usr/share/fonts/opentype/noto/NotoSansCJK.ttc'</span>)</span><br><span class="line">x2 = np.linspace(<span class="number">0.0</span>, <span class="number">2.0</span>)</span><br><span class="line">y2 = np.cos(<span class="number">2</span> * np.pi * x2)</span><br><span class="line">plt.plot(x2, y2)</span><br><span class="line">plt.title(<span class="string">u'一个简单的函数 f = sin(2*pi*x)'</span>, fontproperties=zhfont)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="/image/matplotlib-zh-title-setfonts.png" alt="&#39;matplotlib画图使用中文标签&#39;"></p><h3 id="程序说明："><a href="#程序说明：" class="headerlink" title="程序说明："></a>程序说明：</h3><p>在查找这个中文显示的时候，出现三种方法：<br>1  直接修改matplotlibrc文件里的配置<br>2  在程序中设置matplotlib的rcParams属性里font.sans-serif成一个已知的中文字体名<br>3  第三种就是上面的方法，直接指定渲染用的字体路径  </p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>从表面来看第二种应该是最好的办法，因为不需要修改配置文件，第三种还得查看字体路径，好处是可以制定项目自带的字体而不是系统中已有的字体。第一种跟第二种是一样的效果，不过是修改配置文件，属于环境配置的范畴了。<br>但是前两种都有一个前置条件：系统中已经有的中文字体，并且matplotlib可以自动识别的字体。而经过实验，matplotlib对ttc格式的字体文件用上面的代码可以正常载入，但是使用第二第一种方法的时候，是不会自动载入ttc格式的字体的，只默认支持ttf格式的字体，这就造成了ubuntu 16.04中虽然有默认的中文字体（自带谷歌版本的思源黑体），但是因为都是ttc格式的，所以使用前两种方法制定字体名的时候无法载入  </p><h3 id="吸取的教训"><a href="#吸取的教训" class="headerlink" title="吸取的教训"></a>吸取的教训</h3><ul><li>不同操作系统环境下可能会造成不同的效果</li><li>相同的代码随着时间的推移可能因为软件版本的问题出现新的问题  </li><li>网上的教程里的方法，不能钻牛角尖</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;因为个人非常想要学习机器学习，但是python关于机器学习到一些相关库都不熟悉，那就需要了解python相关到库，numpy是基础，matplotlib是显示相关的库，也得知道，所以开始学习matplotlib画图了。&lt;br&gt;本篇文章主要是简单的使用matplotlib画出一副简单的图片，然后添加一个中文标题&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jingniao.github.io/tags/python/"/>
    
      <category term="matplotlib" scheme="https://jingniao.github.io/tags/matplotlib/"/>
    
      <category term="中文" scheme="https://jingniao.github.io/tags/%E4%B8%AD%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>python使用websocket的几种方式</title>
    <link href="https://jingniao.github.io/2016/04/10/python-websocket/"/>
    <id>https://jingniao.github.io/2016/04/10/python-websocket/</id>
    <published>2016-04-10T09:06:30.000Z</published>
    <updated>2019-08-06T01:12:29.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>websocket 是一种html5新的接口，以前服务器推送需要进行ajax等方式进行轮训，对服务器压力较高，随着新标准的推进，使用websocket在推送等方面已经是比较成熟了，并且各个浏览器对websocket的支持情况已经比较好了，只要不是太老古古董，对这些暂时不考虑。<br>使用websocket的时候，前端使用是比较规范的，js支持ws协议，感觉上类似于一个轻度封装的socket协议，只是以前需要自己维护socket的连接，现在能够以比较标准的方法来进行。<br>总的来说因为前端是js，所以后端对websocket支持最好的是socket.io，在搜索websocket相关的内容的时候感觉socket.io对这个的推广也是不少的，但是现在使用的是python，因为新学习python<br>事件不长，各个框架都在接触一点还是有好处了。<br><a id="more"></a>  </p><h2 id="常用框架："><a href="#常用框架：" class="headerlink" title="常用框架："></a>常用框架：</h2><ul><li>uwsgi</li><li>flask</li><li>tornado</li><li>django</li></ul><p>下面几个都是一个回音壁程序，也就是接受前端js发过来的websocket信息，然后将websocket再原路返回<br>前端js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> WebSocket(<span class="string">"%s://%s/foobar/"</span>);</span><br><span class="line">s.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">s.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">s.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">s.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line">s.send(value);</span><br></pre></td></tr></table></figure></p><p>这几条就是常用的js使用websocket的代码，处理逻辑没有写，要看完整的看下面uwsgi的官方给的例子，我基本上是照搬的。连接回掉，获取信息回掉，错误回掉，关闭回掉，以及发送信息</p><h3 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h3><p>官方文档已经很好了，第一个成功执行的websocket程序就是uwsgi，然后才慢慢的前端不变，然后后端找其他的方案，官方给的例子也是简单易懂的，例子在<a href="https://github.com/unbit/uwsgi/blob/master/tests/websockets_chat_async.py" target="_blank" rel="noopener">websockets_chat_async.py</a>，从这个例子来看，只用uwsgi，需要维护太多的内容，html与python混在一起实在不太好看，所幸这个例子足够简单。  </p><h3 id="flask-uwsgi-websocket"><a href="#flask-uwsgi-websocket" class="headerlink" title="flask-uwsgi-websocket"></a>flask-uwsgi-websocket</h3><p><a href="https://github.com/zeekay/flask-uwsgi-websocket" target="_blank" rel="noopener">flask-uwsgi-websocket</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template</span><br><span class="line"><span class="keyword">from</span> flask.ext.uwsgi_websocket <span class="keyword">import</span> GeventWebSocket</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">ws = GeventWebSocket(app)</span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"><span class="meta">@ws.route('/foobar')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(wscon)</span>:</span></span><br><span class="line">    msg = wscon.receive()</span><br><span class="line">    <span class="keyword">if</span> msg <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wssss.send(msg)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(gevent=<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p><p>这里使用flask自带python容器进行执行python web<br>从上面代码可以看到，使用很简单，其余部分跟普通的flask都没有区别，只需要在需要更改websocket的url请求修饰符，修饰符的来源是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws = GeventWebSocket(app)</span><br></pre></td></tr></table></figure></p><p>很简单也很强大，前端库因为逻辑不需要更改，所以感觉挺好的，但是这个库<a href="https://github.com/zeekay/flask-uwsgi-websocket" target="_blank" rel="noopener">Flask-uWSGI-WebSocket</a>好像有个bug,在用这个库的时候，前端js持续接收到空的消息然后触发了onmessage回掉函数，在使用同样的前端js，其他后端库的时候没有这个问题。  </p><h3 id="geventwebsocket"><a href="#geventwebsocket" class="headerlink" title="geventwebsocket"></a>geventwebsocket</h3><p><a href="https://bitbucket.org/noppo/gevent-websocket" target="_blank" rel="noopener">geventwebsocket</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template, abort</span><br><span class="line"><span class="keyword">from</span> geventwebsocket.handler <span class="keyword">import</span> WebSocketHandler</span><br><span class="line"><span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/foobar')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.environ.get(<span class="string">'wsgi.websocket'</span>):</span><br><span class="line">        ws = request.environ[<span class="string">'wsgi.websocket'</span>]</span><br><span class="line">        <span class="keyword">if</span> ws <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            abort(<span class="number">404</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>  ws.closed:</span><br><span class="line">                    message = ws.receive()</span><br><span class="line">                    ws.send(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    http_server = WSGIServer((<span class="string">''</span>,<span class="number">5000</span>), app, handler_class=WebSocketHandler)</span><br><span class="line">    http_server.serve_forever()</span><br></pre></td></tr></table></figure></p><p>这段代码同样使用了flask来进行模板，url之类的解析，不同之处是不再使用flask自带的容器，而是当作一个应用，被gevent里的一个uwsgiserver容器来调用。<br>而与普通使用方法不同的是注入了handler_class这个类，替换成websocket类型的，具体实现还没有看，但是从逻辑上可以理解，原来的wsgiserver不理解websocket，所以换一个理解websocket的类来进行处理，<br>所以在foobar的程序中才可以从request的环境变量里获取websocket连接，从这里来看，websockethandler也对websocket连接进行了维护工作，简化了很多工作。  </p><p>需要注意的是，这个库当前最新版本是0.9.5，网上搜到了一个教程，但是它的版本针对的是0.3.5版本的，这个库的维护者还进行了变更，其中有些api好像有了变化，需要注意。</p><h3 id="tornado"><a href="#tornado" class="headerlink" title="tornado"></a>tornado</h3><p><a href="http://www.tornadoweb.org/en/stable/websocket.html" target="_blank" rel="noopener">tornado_websocket文档</a><br>文档已经很全面了，就不贴代码了<br>优点，回掉方式，在异步化之后，并发处理能力应该不错，因为是原生支持websocket而不像flask需要寻找第三方插件，所以可能更值得信赖<br>官方给的一个聊天室的例子就很好<a href="https://github.com/tornadoweb/tornado/blob/master/demos/websocket/chatdemo.py" target="_blank" rel="noopener">tornado_chatroom</a>，坑比前面两个flask的少。值得推荐  </p><h3 id="dwebsocket"><a href="#dwebsocket" class="headerlink" title="dwebsocket"></a>dwebsocket</h3><p><a href="https://github.com/duanhongyi/dwebsocket" target="_blank" rel="noopener">dwebsocket</a><br>官方的没什么坑，django的一个插件，处理websocket，在django这个同步阻塞的库里给了websocket的方法。确实值得推荐，暂时不知道是怎么绕过django的同步阻塞的，有时间了看看它的代码，反正好像代码量也不多的样子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> dwebsocket <span class="keyword">import</span> require_websocket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@require_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foobar</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        message = request.websocket.wait()</span><br><span class="line">        request.websocket.send(<span class="string">"return: "</span>+ message)</span><br></pre></td></tr></table></figure></p><p>跟flask的第一个库一样，都是只需要添加一个修饰符就可以了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>折腾了一天多的时间。个人比较感兴趣的几个python的websocket的使用，算是搞通了，至少自己不管是照搬还是适配，总算是能用了。<br>uwsgi感觉比较原始的控制html，控制返回，独自使用好像不太方便，实际上第一个flask的例子后端应该就是使用uwsgi的，从它的名字就可以看到。<br>Flask-uWSGI-WebSocket和dwebsocket的方式类似，只是一个用于flask，一个用于django，但是前者有个不大不小的bug，给人感觉不太成熟的样子，后者倒是感觉不错，对于django来说，挺不错的样子，不过django的1.9版本出来了一个通道功能，用于执行类似于websocket的后台长时间的功能，找时间了解下，不过这个功能好像还是插件式提供的语句在，好像在下一个django会合到主分支版本的样子，文档在：<br><a href="https://channels.readthedocs.org/en/latest/" target="_blank" rel="noopener">Django Channels</a><br>tornado是一个新兴的异步框架，了解的不多，感觉上跟flask和django不太一样。但是可以作为利器使用，新手就不多说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;websocket 是一种html5新的接口，以前服务器推送需要进行ajax等方式进行轮训，对服务器压力较高，随着新标准的推进，使用websocket在推送等方面已经是比较成熟了，并且各个浏览器对websocket的支持情况已经比较好了，只要不是太老古古董，对这些暂时不考虑。&lt;br&gt;使用websocket的时候，前端使用是比较规范的，js支持ws协议，感觉上类似于一个轻度封装的socket协议，只是以前需要自己维护socket的连接，现在能够以比较标准的方法来进行。&lt;br&gt;总的来说因为前端是js，所以后端对websocket支持最好的是socket.io，在搜索websocket相关的内容的时候感觉socket.io对这个的推广也是不少的，但是现在使用的是python，因为新学习python&lt;br&gt;事件不长，各个框架都在接触一点还是有好处了。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="websocket" scheme="https://jingniao.github.io/tags/websocket/"/>
    
      <category term="django" scheme="https://jingniao.github.io/tags/django/"/>
    
      <category term="flask" scheme="https://jingniao.github.io/tags/flask/"/>
    
      <category term="tornado" scheme="https://jingniao.github.io/tags/tornado/"/>
    
      <category term="gevent" scheme="https://jingniao.github.io/tags/gevent/"/>
    
      <category term="uwsgi" scheme="https://jingniao.github.io/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>let&#39;s Encrypt的使用以及nginx的http2的配置</title>
    <link href="https://jingniao.github.io/2016/04/08/nginx-http2-letsencrypt/"/>
    <id>https://jingniao.github.io/2016/04/08/nginx-http2-letsencrypt/</id>
    <published>2016-04-08T21:57:23.000Z</published>
    <updated>2019-08-06T01:12:29.481Z</updated>
    
    <content type="html"><![CDATA[<p>本文大量参考了Jerry Qu的博客<br><a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="noopener">Let’s Encrypt，免费好用的 HTTPS 证书</a></p><h2 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ssl</span><br><span class="line"><span class="built_in">cd</span> ssl/</span><br></pre></td></tr></table></figure><a id="more"></a> <h2 id="创建本地密钥"><a href="#创建本地密钥" class="headerlink" title="创建本地密钥"></a>创建本地密钥</h2><p>这里集中不同的密钥，注意区分<br>用户密钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa 4096 &gt; account.key</span><br></pre></td></tr></table></figure></p><p>域名密钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa 4096 &gt; git.letus.club.key</span><br></pre></td></tr></table></figure></p><p>生成csr证书请求文件<br>交互模式生成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -sha256 -key git.letus.club.key -out git.letus.club.csr</span><br></pre></td></tr></table></figure></p><p>按照提示信息填写相关信息：默认不进行填写也可以<br>生成的csr文件的开头是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE REQUEST-----</span><br></pre></td></tr></table></figure></p><h2 id="域名配置验证服务"><a href="#域名配置验证服务" class="headerlink" title="域名配置验证服务"></a>域名配置验证服务</h2><p>在进行证书签名的时候证书机构需要知道你拥有这个域名的所有权，类似于谷歌站长的验证方式  </p><h3 id="配置nginx的验证目录"><a href="#配置nginx的验证目录" class="headerlink" title="配置nginx的验证目录"></a>配置nginx的验证目录</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  git.letus.club;</span><br><span class="line"></span><br><span class="line">    location ^~ /.well-known/acme-challenge/ &#123;</span><br><span class="line">        alias /var/challenges/;</span><br><span class="line">        try_files $uri =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        rewrite ^/(.*)$ https://git.letus.club/$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下载脚本，获取验证过的网站证书"><a href="#下载脚本，获取验证过的网站证书" class="headerlink" title="下载脚本，获取验证过的网站证书"></a>下载脚本，获取验证过的网站证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</span><br></pre></td></tr></table></figure><p>验证并获取证书文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python acme_tiny.py --account-key ./account.key \</span><br><span class="line">    --csr ./git.letus.club.csr \</span><br><span class="line">    --acme-dir /root/challenges/ &gt; ./signed.crt</span><br></pre></td></tr></table></figure></p><p>执行脚本的时候python库可能缺少，需要安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install python-argparse</span><br></pre></td></tr></table></figure></p><p>上面的acme_tiny.py脚本输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Parsing account key...</span><br><span class="line">Parsing CSR...</span><br><span class="line">Registering account...</span><br><span class="line">Already registered!</span><br><span class="line">Verifying git.letus.club...</span><br><span class="line">git.letus.club verified!</span><br><span class="line">Signing certificate...</span><br><span class="line">Certificate signed!</span><br></pre></td></tr></table></figure></p><p>这个过程需要验证服务是否可用<br>所以保证通过指定域名能够访问文件<br>nginx里的alias指向的地址跟指定的acme-dir地址应该一致，并且保证有相关权限<br>生成一个crt文件，文件开头是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br></pre></td></tr></table></figure></p><p>获取上级证书并组成证书链<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem \</span><br><span class="line">    &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br></pre></td></tr></table></figure></p><p>到这里就配置成功了证书文件了</p><h2 id="nginx的http2配置"><a href="#nginx的http2配置" class="headerlink" title="nginx的http2配置"></a>nginx的http2配置</h2><p>一个完成的配置文件如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl http2;</span><br><span class="line">    server_name git.letus.club</span><br><span class="line">    ssl on;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /root/ssl/chained.pem;</span><br><span class="line">    ssl_certificate_key /root/ssl/git.letus.club.key;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后重启nginx<br>访问git.letus.club网址查看证书：<br><img src="/image/letsencrypt_cert.png" alt="&quot;网站证书&quot;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大量参考了Jerry Qu的博客&lt;br&gt;&lt;a href=&quot;https://imququ.com/post/letsencrypt-certificate.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Let’s Encrypt，免费好用的 HTTPS 证书&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建工作目录&quot;&gt;&lt;a href=&quot;#创建工作目录&quot; class=&quot;headerlink&quot; title=&quot;创建工作目录&quot;&gt;&lt;/a&gt;创建工作目录&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir ssl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; ssl/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="运维" scheme="https://jingniao.github.io/categories/devops/"/>
    
    
      <category term="nginx" scheme="https://jingniao.github.io/tags/nginx/"/>
    
      <category term="http2" scheme="https://jingniao.github.io/tags/http2/"/>
    
      <category term="letsencrypt" scheme="https://jingniao.github.io/tags/letsencrypt/"/>
    
  </entry>
  
  <entry>
    <title>python学习——supervisor和redis,pgsql数据库连接</title>
    <link href="https://jingniao.github.io/2016/04/06/python-lean-supervisor-redis-pgsql/"/>
    <id>https://jingniao.github.io/2016/04/06/python-lean-supervisor-redis-pgsql/</id>
    <published>2016-04-06T00:21:35.000Z</published>
    <updated>2019-08-06T01:12:29.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目考虑使用守护进程，所以在看这方面的东西。管理使用supervisor来管理。很方便的使用supervisor<br><a id="more"></a> </p><h3 id="supervisor使用"><a href="#supervisor使用" class="headerlink" title="supervisor使用"></a>supervisor使用</h3><p>1，安装supervisor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install supervisor</span><br></pre></td></tr></table></figure></p><p>2，配置supervisor，/etc/supervisord.d/下以ini为扩展名的都是配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:ddd]</span></span><br><span class="line"><span class="attr">command</span>=/root/daemon.py</span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>command指向要执行的命令就可以了</p><h3 id="redis数据库的链接以及消息队列"><a href="#redis数据库的链接以及消息队列" class="headerlink" title="redis数据库的链接以及消息队列"></a>redis数据库的链接以及消息队列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">rd = redis.StrictRedis(host=<span class="string">"localhost"</span>)</span><br><span class="line">rd.publish(uid,testnum)</span><br><span class="line"><span class="comment">#以上是向某个频道（channel）发布消息</span></span><br><span class="line">channel = rd.pubsub()</span><br><span class="line">channel.subscribe(uid)</span><br><span class="line">msg = channel.parse_response()</span><br><span class="line"><span class="comment"># 这个方法会阻塞执行，如果redis消息队列</span></span><br><span class="line"><span class="comment"># 里没有消息，则会停在这里。</span></span><br><span class="line">rd_fd = channel.connection._sock.fileno()</span><br><span class="line"><span class="comment"># 获取频道的socket？类似于文件句柄的东西。这样就能</span></span><br><span class="line"><span class="comment"># 用select或者epoll模型监听这个socket？从而判断是否</span></span><br><span class="line"><span class="comment"># 有消息？这点存疑，以后用的时候在研究了</span></span><br><span class="line">ready = select.select([rd_fd], [], [], <span class="number">4.0</span>)</span><br><span class="line"><span class="comment"># 参数，三个列表，等待读取列表，等待写入列表，</span></span><br><span class="line"><span class="comment"># 等待错误列表，最后是等待时间，这个函数会阻塞</span></span><br><span class="line"><span class="comment"># 执行，这个是超时时间。</span></span><br></pre></td></tr></table></figure><h3 id="postgresql数据库，使用python链接"><a href="#postgresql数据库，使用python链接" class="headerlink" title="postgresql数据库，使用python链接"></a>postgresql数据库，使用python链接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conn = psycopg2.connect(host=self.host, </span><br><span class="line">    user=self.user, password=self.passwd) </span><br><span class="line">    <span class="comment">#链接到数据库</span></span><br><span class="line">r = conn.cursor() <span class="comment">#获取游标</span></span><br><span class="line">r.execute(self.query[‘config’]) <span class="comment">#进行sql语句的使用</span></span><br><span class="line">r.close()</span><br><span class="line">conn.commit() <span class="comment">#提交事务</span></span><br><span class="line">conn.close() <span class="comment">#关闭游标以及数据库</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;项目考虑使用守护进程，所以在看这方面的东西。管理使用supervisor来管理。很方便的使用supervisor&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jingniao.github.io/categories/python/"/>
    
    
      <category term="supervisor" scheme="https://jingniao.github.io/tags/supervisor/"/>
    
      <category term="redis" scheme="https://jingniao.github.io/tags/redis/"/>
    
      <category term="postgresql" scheme="https://jingniao.github.io/tags/postgresql/"/>
    
  </entry>
  
</feed>
